<div class="panel panel-info" ng-controller="ObserverCtrl as observer">
  <div class="panel-heading">
    Observer Pattern
  </div>
  <div class="panel-body">
    <form name="oopForm" ng-submit="observer.submit(oopForm)">
      <p>1. 개념 이해</p>
      <p>자기 자신이 비디오 가게 주인이라고 가정한다. 비디오가게 고객이 100명이고 100명에 대한 신상정보를 저장하고 있는
        고객관리 프로그램을 가지고 있다고 가정한다. 새로운 신작 비디오가 출시되었을 경우 고객은 그 사실을 알지 못한다.
        그러므로 관심있는 고객은 퇴근길에 비디오가게에 들러서 가게 주인에게 신작 비디오가 출시되었는지를 물어볼것이다.
        백명중에 50명이 물어보더라도 비디오 가게 주인은 하루에 50번을 대답해줘야 한다. 신작비디오가 일주일에 한번
        출시되더라도 하루 평균 50번을 대답해줘야 한다. 이러한 구조를 폴링 아키텍처라고 한다. 폴링 아키텍처의 반대가 푸쉬
        아키텍처이다. 자기 자신이 비디오 가게 주인이라면 신작 비디오가 도착할 경우 어떻게 고객한테 한꺼번에 알려줄것인가?
        (고객관리 프로그램에는 비디오가게의 메시지를 받겠다는 수신동의 필드가 존재한다고 가정한다) (5점) <br />
        <textarea placeholder="1" ng-model="observer.feedback[0].content" rows="5" style="width:100%;" required></textarea>
      </p>

      <p>2. 모델링</p>
      <p>
        1) 개념 <br />
        a) 날씨정보를 제공하는 기상센터가 있고, 기상센터에 접속하여 날씨정보를 가져가는 다수의 콘솔 클라이언트, 안드로이드 클라이언트가
        존재한다고 가정한다. 클라이언트가 기상센터에 폴링하여 날씨를 가져가게 되는 폴링 아키텍처라고 가정한다면, 클라이언트가
        한 두개일 경우는 문제가 없겠지만 100개의 클라이언트가 있다고 가정하고 그 클라이언트가 언제 날씨가 변하는지 알수가
        없으므로 1분마다 폴링한다고 가정한다면 기상센터 입장에서 하루에 몇번의 폴링이 발생하는가? (2점)<br />
        <textarea placeholder="2" ng-model="observer.feedback[1].content" rows="1" required></textarea><br />
        b) 위의 비디오 가게와 비교한다면 비디오가게 주인과 고객에 해당하는 부분은 무엇인가?(3점) <br />
        <textarea placeholder="3" ng-model="observer.feedback[2].content" rows="1" style="width: 100%;" required></textarea><br />
      </p>
      <p>
        이것을 observer 패턴을 사용한 푸쉬 아키텍처로 모델링하여 보자.<br />
        <img src="/assets/images/oop/observer.cld.jpg" /><br />
        2) 클라이언트 추상화<br />
        a) Observer 패키지의 Client 인터페이스를 위의 UML을 보고 작성하시오.<br />
        코딩시 오류가 나면 WeatherGenerator는 abstract 클래스로 생성만 하여 둔다.(5점)<br />
        <div placeholder="4" ui-codemirror ng-model="observer.feedback[3].content" ui-codemirror-opts="observer.editorOptions" style="border: 1px solid #aaaaaa;" required></div>
        b) Client를 인터페이스로 추상화를 하는 이유는 무엇인가? 기상센터에 접속하여 날씨정보를 제공하고자하는 Client 앱이
        아주 다양하다고 가정하시오. (10점)<br />
        <textarea ng-model="observer.feedback[4].content" rows="5" style="width:100%;" required></textarea>

        3) 기상센터 추상화<br />
        Observer 패키지의 WeatherGenerator 클래스는 추상 클래스이다. 위의 UML을 보고 작성한다.<br />
        mObservers는 명시적 초기화를 수행한다.<br />
        addObserver 함수는 파라메터로 넘어온 Client를 받아서 mObservers에 추가한다.<br />
        deleteObserver 함수는 파라메터로 넘어온 Client를 받아서 mObservers에서 제거한다.<br />
        notifyObservers는 mObservers의 모든 Client의 update함수를 호출한다. update의 파라메터는 자기자신을 넘겨준다.<br />
        getTemperature 함수는 client가 온도를 얻어가는 함수로 추상함수이다.<br />
        generateTemperature 함수는 임의의 온도를 생성하는 추상함수이다.(15점)<br />
        <div ui-codemirror ng-model="observer.feedback[5].content" ui-codemirror-opts="observer.editorOptions" style="border: 1px solid #aaaaaa;" required></div>

        4) 기상센터 구현<br />
        RandomWeatherGenerator를 작성하시오. 위의 UML을 보고 작성한다.<br />
        random 변수는 java.util.Random클래스의 인스턴스 변수로 명시적 초기화를 수행<br />
        getTemperature 함수는 mTemperature를 리턴한다.<br />
        generateTemperature 함수는 0-10초 사이를 랜덤하게 sleep한 다음 0-30 사이의 숫자를 랜덤으로 생성하여 mTemperature에 할당하는데
        3번 반복한다. (20점)<br />
        <div ui-codemirror ng-model="observer.feedback[6].content" ui-codemirror-opts="observer.editorOptions" style="border: 1px solid #aaaaaa;" required></div>

        5) 클라이언트 구현<br />
        a) ConsoleClient 구현. 위의 UML을 보고 작성한다.<br />
        숫자로 출력한다.(5점)<br />
        <div ui-codemirror ng-model="observer.feedback[7].content" ui-codemirror-opts="observer.editorOptions" style="border: 1px solid #aaaaaa;" required></div>
        b) AndroidClient 구현. 위의 UML을 보고 작성한다.<br />
        숫자만큼 *의 갯수로 출력한다. (10이면 *을 10개 출력) (5점)<br />
        <div ui-codemirror ng-model="observer.feedback[8].content" ui-codemirror-opts="observer.editorOptions" style="border: 1px solid #aaaaaa;" required></div>

        6) 메인 함수 구현<br />
        a) Main 클래스에 public static void main 함수를 구현한다.<br />
        RandomWeatherGenerator 인스턴스를 생성하여 WeatherGenerator에 할당한다. 변수명은 generator라고 하자<br />
        ConsoleClient 인스턴스를 생성하여 Client 인터페이스에 할당 후 변수명은 client1 이라고 하자<br />
        ConsoleClient 인스턴스를 하나더 생성하여 Client 인터페이스에 할당 후 변수명은 client2 이라고 하자<br />
        AndroidClient 인스턴스를 생성하여 Client 인터페이스에 할당 후 변수명은 client3이라고 하자.<br />
        generator의 addObserver 함수를 호출하여 client1 인스턴스를 등록<br />
        generator의 addObserver 함수를 호출하여 client3 인스턴스를 등록<br />
        실행하여 아래와 같은 결과가 나오도록 하자. 물론 나오는 숫자는 랜덤이므로 같을수는 없다. (15점)<br />
        <div style="border: 1px dashed #999999; margin: 5px;padding: 5px 10px;">
          Weather Cast Start<br />
          ConsoleClient:24<br />
          AndroidClient:************************<br />
          ConsoleClient:10<br />
          AndroidClient:**********<br />
          ConsoleClient:2<br />
          AndroidClient:**<br />
          Weather Cast End<br />
        </div>
        <div ui-codemirror ng-model="observer.feedback[9].content" ui-codemirror-opts="observer.editorOptions" style="border: 1px solid #aaaaaa;" required></div>
        b) generator의 generatorTemperature를 호출하면 온도를 랜덤하게 3번 생성하는 기상센터가 작동할것이고, 온도가 생성되면
        등록된 클라이언트에게 생성된 온도를 푸쉬하게 된다. 그러나 모든 클라이언트에게 푸쉬를 하는것이 아니라, 받고자 원하는
        고객한테만 푸쉬를 한다. 그 부분이 코드상으로 어느 부분이고, 푸쉬를 받지 못한 클라이언트는 누구인가? (10점)
        <textarea ng-model="observer.feedback[10].content" rows="5" style="width:100%;" required></textarea>
      </p>
      <div style="text-align: center;">
        <md-button type="submit" class="md-raised md-primary">제   출</md-button>
      </div>
    </form>
  </div>
</div>
